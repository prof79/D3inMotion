<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>Shopping App</title>
    
    <style type="text/css">
    
        h1, h2, h3, h4, h5, p, div, span
        {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        svg text
        {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 28pt;
        }

    </style>

</head>

<body>
    
    <h1>Shopping App</h1>

    <svg width="500" height="960"></svg>

    <script src="https://d3js.org/d3.v4.min.js"></script>

    <script>
    
        const margin = { left: 50, top: 50, right: 20, bottom: 50 };

        const svg =
            d3
            .select('svg');

        const width = +svg.attr('width');
        const height = +svg.attr('height');
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const g =
            svg
            .append('g')
            .attr('transform', function (d) {
                return 'translate(' + margin.left + ' ' + margin.top + ')';
            });

        // Y (vertical axis) will be a band scale.
        const yScale =
            d3
            .scaleBand()
            .paddingInner(0.08)
            // Outer padding must be half of inner ... but why?
            // Maybe because of number of items and resulting spacing ...
            .paddingOuter(0.04);

        // X (horizontal axis) will be a linear, price-based scale.
        const xScale = d3.scaleLinear();
        
        // Vertical spacing for item text.
        const verticalSpacing = 56;

        // Accessor for item name.
        const itemName = function (d) {
            return d.name;
        }

        // Accessor for item price.
        const itemPrice = function (d) {
            return d.price;
        }

        // Nicely format a grocery item.
        const textValue = function (d) {
            return d.name + ' $' + d.price;
        }

        const render = function (selection, data) {

            // We will use vertical bars for visualization.

            // X - bar width, price scaled to pixels
            xScale
                .domain([0, d3.max(data, itemPrice)])
                .range([0, innerWidth]);
            
            // Y - bar height, even portions based on number of elements.
            yScale
                .domain(data.map(itemName))
                .range([0, data.length * verticalSpacing]);

            // Create groups for all bar-text pairs.
            // This and what follows is the general update pattern.
            const subGroups =
                selection
                    .selectAll('g')
                    .data(data);

            subGroups
                .exit()
                    .remove();
            
            const subGroupsEnter =
                subGroups
                    .enter()
                        .append('g');

            subGroups
                .merge(subGroupsEnter)
                    .attr('transform', function (d) {
                        return 'translate('
                            + 0
                            + ' '
                            + (yScale(itemName(d)))
                            + ')';
                    })

            // Bars behind text data join.
            // Nested general update pattern in action.
            const bars =
                subGroupsEnter
                    .append('rect')
                        .attr('fill', 'steelblue')
                    // Select what already had been there.
                    // This gets the update selection of already existing
                    // rect elements.
                    .merge(subGroups.select('rect'))
                        .attr('width', function (d) {
                            return xScale(itemPrice(d));
                        })
                        .attr('height', function (d) {
                            return yScale.bandwidth();
                        })
                    ;
            
            // Item names.
            // Nested general update pattern in action.

            // Background text ("stroke").
            const textBackground =
                subGroupsEnter
                    .append('text')
                        .attr('class', 'textBackground')
                        .attr('dx', '0.2em')
                        .attr('dy', '1.0em')
                        .attr('fill', 'none')
                        .attr('stroke', 'white')
                        .attr('stroke-width', 5)
                        .attr('stroke-linejoin', 'round')
                    // Select what already had been there.
                    // This gets the update selection of already existing
                    // text elements.
                    .merge(subGroups.select('.textBackground'))
                        .text(textValue)
                    ;
            
            // Foreground text.
            const textForeground =
                subGroupsEnter
                    .append('text')
                        .attr('class', 'textForeground')
                        .attr('dx', '0.2em')
                        .attr('dy', '1.0em')
                    // Select what already had been there.
                    // This gets the update selection of already existing
                    // text elements.
                    .merge(subGroups.select('.textForeground'))
                        .text(textValue)
                    ;
        }

        // Groceries
        const shoppingCart = [
            { name: 'Milk', price: 3 } 
        ];

        render(g, shoppingCart);

        // Push a new item onto the list after 2 seconds.
        setTimeout( function () {
            
            shoppingCart.push(
                { name: 'Eggs', price: 20 }
            );

            render(g, shoppingCart);
        }
        , 1000);

        // Change the price of eggs ie. update an existing item.
        setTimeout(function () {

            render(g, [
                { name: 'Milk', price: 3 },
                { name: 'Eggs', price: 2 }
            ]);
        }
        , 2000);

        // Add another new item we are going to remove later.
        setTimeout(function () {

            render(g, [
                { name: 'Milk', price: 3 },
                { name: 'Eggs', price: 2 },
                { name: 'Cupcakes', price: 5 }
            ]);
        }
        , 3000);

        // Now the cupcakes are gone (removed).
        setTimeout(function () {

            render(g, [
                { name: 'Milk', price: 3 },
                { name: 'Eggs', price: 2 },
            ]);
        }
        , 4000);
    
    </script>

</body>

</html>
